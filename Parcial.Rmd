---
title: "Parcial"
author: "Andres David Gomez B"
date: "28 de febrero de 2018"
output:
  html_document:
    df_print: null
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1. Matriz triangular
a)Primer punto usa como ejemplo una matriz triangular de 3x3
```{r}
rm(list=ls())
cat("recuerde que la matriz debe ser cuadrada para que el algoritmo funcione","\n") 
superior <- function(a) {
y<-(dim(a))
i<-1
sum<-0
j<-1
while(i<=y[c(1)])
{
  j<-i
  while(j<=y[c(1)])
  {
    sum<-sum+a[(i),(j)]
    j<-j+1
  }
  i<-i+1
}
cat(sum)
}
a<-matrix(c(1,1,1,0,1,1,0,0,1), nrow=3, byrow=T)
superior(a)

```

b) Dada la formula basta con el siguiente codigo que depende del tamaño:
```{r}
rm(list=ls())
cat("Ingrese el tamaño de la matriz  cuadrada","\n") 
eficiencia<- function(a) {
  j<-1
  i<-1
  sum<-0
  while(i<=a){
    j<-i
    while(j<=a)
    {
      sum<-sum+1
      j<-j+1
    }    
    i<-i+1
  }
cat(sum)
}
eficiencia(4)

```
c) Se prueba la funcion con varios valores:
```{r}
rm(list=ls())
eficiencia<- function(a) {
  j<-1
  i<-1
  sum<-0
  while(i<=a){
    j<-i
    while(j<=a)
    {
      sum<-sum+1
      j<-j+1
    }    
    i<-i+1
  }
cat(sum)
}

i<-2
while(i<=25){
  cat(eficiencia(i),"\n")
  i<-i+1
}

```
Con estos datos podemos concluir que  la notacion O() mas cercana es   : notacion O(nlog(n))
## 2. Numeros Aitken
Primero se evalua la sucesion mediante el metodo de biseccion:


```{r}
# Remueve todos los objetos creados
rm(list=ls())
# Halla la raiz de Fx
Aitken <- function(a,b,c) {
  x<-0
  error<-1
  while (error > 1.e-4) {
    #if (Fx(x) == 0) break
    y<-x
    x<-(a-(((b-a)^2)/(c-2*b+a)))
    a<-b
    b<-c
    c<-x
    error<-abs(y-x)
    cat("X=",x,"\tE=",error,"\n")
  }
}
#Aitken(1,1,1)
```
##3 Secante
Se usa el metodo de la secante

# Metodo de secante
# Remueve todos los objetos creados
rm(list=ls())
Fx <- function(x) log(x+2)-sin(x)
F1x <- function(x) (1/(x+2))-cos(x)
# Halla la raiz de Fx
secante <- function(x0,x1) {
  x<-seq(-2,0,0.001)
  plot(x,Fx(x),type="l",col="blue")
  abline(h=0,col="blue")
  x<-(Fx(x1)*x0-Fx(x0)*x1)/(Fx(x1)-Fx(x0))
  error <-1
  while (error > 1.e-7) {
    x0<-x1
    x1<-x
    x<-(Fx(x1)*x0-Fx(x0)*x1)/(Fx(x1)-Fx(x0))
    if (Fx(x) == 0) break
    error<-abs(Fx(x)/F1x(x))
    points(rbind(c(x,0)),pch=19,cex=0.7,col="red")
    cat("X=",x,"\t","E=",error,"\n")
  }
}
secante(-2,0)



b) 

# Metodo de Newton

rm(list=ls())
Fx <- function(x) log(x+2)-sin(x)
F1x <- function(x) (1/(x+2))-cos(x)
# Metodo de Newton
# Halla la raiz de 
Newton <- function(x0) {
  x<-seq(0,20,1)
  plot(x,Fx(x),type="l",col="blue")
  abline(h=0,col="blue")
  x<-x0-(Fx(x0)/F1x(x0))
  error <-1
  while (error > 1.e-5) {
    x<-x-(Fx(x)/F1x(x))
    if (Fx(x) == 0) break
    error<-abs(Fx(x)/F1x(x))
    points(rbind(c(x,0)),pch=19,cex=0.7,col="red")
    cat("X=",x,"\t","E=",error,"\n")
  }
}
Newton(1)

